# 部分和问题

n 个数中选 k 个数使其和为 sum,求方案数

- 方案一  
遍历每一个数,分别 dfs 选该数与不选该数的情况,选完 n 个数后判断和是否为 sum

```c
//代表方案数
int ans;

//代表第1到第n个数
int a[n+1];

//记录目标和
int sum;

//i为选择到了第i个数,cnt代表已经选择了几个数,s为当前总和
void dfs(int i,int cnt,int s){
    if(s > sum){
        return;
    }
    if(i == n){
        if(cnt == k && s == sum){
            ans++;
        }
        return;
    }
    dfs(i+1, cnt, s);
    dfs(i+1, cnt+1, s+a[i])
}
```

- 方案二  
建立搜索树,对情况进行搜索

```c
//x[i]代表第i个数的选择情况,false代表为未选过;true代表选过
bool x[n+1];

//cnt代表已经选了几个数,s代表当前和
void dfs(int cnt,int s){
    if(s > sum) {
		return;
	}
    if(cnt == k ){
        if(s == sum){
            ans++;
        }
        return;
    }
    for(int i = 1;i<=n;i++){
        if(!x[i]){
            x[i] = true;
            dfs(cnt+1,s+a[i]);
            x[i] = false;
        }
    }
}
```

但是这种方法会造成`重复查找`,原因:

假设现在有 5 个数,需找 3 个数使其和为 k,假设这三个数为 a1,a2,a3,那么搜索情况如下:
![](https://cdn.hurra.ltd/img/20200812214720.png)
展示了搜索树的部分情况;由此可见,在查找 a1,a2,a3 时,实际满足条件搜索情况为:  
a1,a2,a3  
a1,a3,a2    
a2,a1,a3  
a2,a3,a1    
a3,a1,a2   
a3,a2,a1  
共六种情况,但这六种情况实际为同一种方案,出现了重复搜索,则查找 k 个数和为 sum 时,实际找出的情况为 $k!$种,因此最还需除以 $k!$

为避免重复搜索,可以另设一个变量 p,记录下次开始搜索的位置,对重复搜索进行剪枝

```c
void dfs(int p,int cnt,int s) {
	if(s > sum || cnt > k) {
		return;
	}
	if(cnt == k ) {
		if(s == sum) {
			ans++;
		}
		return;
	}
    //下次搜索位置为p,而不是从头开始
	for(int i = p; i<=n; i++) {
		if(!x[i]) {
			x[i] = true;
			dfs(i+1,cnt+1,s+a[i]);
			x[i] = false;
		}
	}
}
```

测试:
![](https://cdn.hurra.ltd/img/20200812224715.png)

n 个数中选若干个数使其和为 sum  
相当于类型一问题中不需要做 cnt == k 的判断,其他部分完全一致

## 多重部分和

$n$ 个数字 $a[i](i = {1,2......n})$,每种数字各 $b[i]$个,判断选出若干数和恰好为 $k$ 的方案数

令 $dp[i][j]$ 代表,选择前 $i$ 个数字,使得和为 $j$ 的方案数

则可得 $dp[i][j] = \sum_0^k dp[i-1][j-k*a[i]] (k=0,1,2......b[i] 且 k*a[i] <= j)$  

即从选择前$i-1$个数,使得和为$j-k*a[i] (k=0,1,2......b[i])$的状态转移而来
```c
int dp[n+1][k+1];

dp[0][0]=1;
for(int i=1;i<=n;i++){
	for(int j=0;j<=k;j++){
		for(int k=0;k<=b[i] && k*a[i]<=j;k++){
			dp[i][j] +=dp[i-1][j-k*a[i]];
		}
    }
}
cout<<dp[n][k];
```

![](https://cdn.hurra.ltd/img/收款码.png)
