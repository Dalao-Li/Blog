- [一、提出](#一提出)
- [二、研究](#二研究)
  - [2.1 常规算法](#21-常规算法)
  - [2.2 快速幂](#22-快速幂)
  - [2.3 代码实现](#23-代码实现)
  - [2.4 教程](#24-教程)

# 一、提出

求 $3^{13}$

# 二、研究

## 2.1 常规算法

$3^{13}$ = 3 _ 3 _ 3 _ 3 _ 3 _ 3 _ 3 _ 3 _ 3 _ 3 _ 3 _ 3 _ 3
需要算 14 次,太麻烦,不符合程序员的逼格

## 2.2 快速幂

$(13)*{10}$ = $(1101)*2$ = 1 _ $2^3$ + 1 _ $2^2$ + 0 _ $2^1$ + 1 _ $2^0$

$3^{13}$ = $3^{1 * 2^3 +1 * 2^2 + 0 * 2^1 + 1 * 2^0
}$

$3^{13}$ = $3^8$ _ $3^4$ _ $3^1$

需要算 7 次,方便运算

推导过程
$3^1$ = $(3^1)$

$3^2$ = $(3^1)^2$

$3^4$ = $(3^2)^2$

$3^8$ = $(3^4)^2$

> 快速幂就是运算过程不断对底数进行平方运算，并当指数的二进制某位为 1 时,保存当前底数的值

## 2.3 代码实现

代码实现

```c
typedef long long ll;
//a为底数,b为指数
ll fastPower(ll a, ll b, ll mod) {
	if(b==0) {
		return 1%mod;
	}
	//res用来保存结果
	ll res = 1;
	while(b) {
		//指数当前位为1时,保存底数的值
		if(b&1) {
			res = (res * a)%mod;
		}
		//判断指数的下一位
		b>>=1;
		//底数做平方运算
		a = (a * a)%mod;
	}
	return res;

}
```

运行结果:

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200624165841917.png?x-oss-process=image/watermark,type*ZmFuZ3poZW5naGVpdGk,shadow*10,text*aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUyOTM3,size*16,color*FFFFFF,t*70)

> `b&1` 表示 b 与 1 进行按位与操作,若 b 当前二进制位为 1 则结果为 1；同时若 b 为奇数时，该操作结果也为 1
>
> `>>` 表示位移运算

## 2.4 教程

[二进制按位与,位移运算教程](https://blog.csdn.net/qq*41452937/article/details/84001444)

![](https://imgconvert.csdnimg.cn/aHR0cDovL2Nkbi5odXJyYS5sdGQvaW1nLyVFOCVCNSU5RSVFOCVCNSU4RiVFNyVBMCU4MS5wbmc?x-oss-process=image/format,png)
