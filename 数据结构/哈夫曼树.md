- [一、 概念](#一-概念)
- [二、 过程](#二-过程)
  - [初始化值](#初始化值)
  - [2.1 建立](#21-建立)
  - [2.2 编码](#22-编码)
- [三、 代码实现](#三-代码实现)
  - [3.1 数据定义](#31-数据定义)
  - [3.2 构建](#32-构建)
  - [3.3 编码](#33-编码)
  - [3.4 全部代码](#34-全部代码)
  - [3.5 运行结果](#35-运行结果)

# 一、 概念

> 给定 N 个权值作为 N 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为哈夫曼树;哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

# 二、 过程

## 初始化值

| 节点 | 权值 |
| ---- | ---- |
| A    | 12   |
| B    | 24   |
| C    | 35   |
| D    | 67   |
| E    | 46   |
| F    | 55   |

## 2.1 建立

每次从所有节点中选出`最小权值节点`与`次小权值节点`,合并;

重复操作至所有节点合并为一棵树

![](http://cdn.hurra.ltd/img/20200624222845.png)

## 2.2 编码

对建立好的哈夫曼树,所有节点左儿子编为 0,右儿子编为 1,实现对各节点的编码
![](http://cdn.hurra.ltd/img/20200624223359.png)

# 三、 代码实现

## 3.1 数据定义

```c++
#define LENGTH 6

// 用以进行哈夫曼编码
int code[20];

// 用以保存每个节点的哈夫曼编码
string huffman[LENGTH];

// 权值
int arr[LENGTH] = {12,24,35,67,46,55};

// 节点
char alph[LENGTH] = {'A','B','C','D','E','F'};

typedef struct Tree {
    //节点的权值
    int data;
    Tree* leftSon;
    Tree* rightSon;
    Tree(int data,Tree* leftSon,Tree* rightSon){
        this->data = data;
        this->leftSon = leftSon;
        this->rightSon = rightSon;
    }
} Tree, *TreeList;

```

## 3.2 构建

```c++
int cmp(TreeList &t1, TreeList &t2){
	return t1->data <= t2->data;
}

//建哈夫曼树,返回根节点
TreeList createTree(int arr[]) {
    //建立指vector用来保存节点信息
    vector<TreeList> v;
    for (int i = 0; i < LENGTH; i++) {
    	TreeList leat = new Tree(arr[i], nullptr, nullptr);
    	v.push_back(leat);
    }
    //哈夫曼树的根节点
    TreeList root = nullptr;
    //容器容量大于1说明还未建立完
    while(v.size() > 1){
    	//按照节点值从小到达排序
    	sort(v.begin(),v.end(),cmp);
        //最小值节点为v0次小值节点为v1
        root = new Tree(v[0]->data + v[1]->data,v[0],v[1]);
		//根节点保存到v1
        v[1] = root;
        v.erase(v.begin());
	}
    return root;
}

```

## 3.3 编码

```c++
//根据权值获取下标
int getIndex(int weight){
	for(int i = 0 ;i<LENGTH;i++){
		if(weight == arr[i]){
			return i;
		}
	}
}

//递归进行哈夫曼树编码,len是当前树的层数
void huffmanCoding(TreeList& root, int len) {
    if (root == nullptr) {
        return;
    }
    //若到叶子节点
    if (root->leftSon == nullptr && root->rightSon == nullptr) {
        //获取该节点权值对应的字符下标
        int index = getIndex(root->data);
        //保存该字符的哈夫曼编码
        for (int i = 0; i < len; i++) {
            huffman[index].push_back(code[i] + '0');
        }
        return;
    }
    //否则继续进行哈夫曼编码的操作
    //左侧分支都记为零
    code[len] = 0;
    huffmanCoding(root->leftSon, len + 1);
    //右侧分支都记为一
    code[len] = 1;
    huffmanCoding(root->rightSon, len + 1);

}
```

## 3.4 全部代码

```c++
/*
        Name: Huffman tree coding
        Copyright:
        Author: YuanHao Li
        Date: 20/5/24 15:22
        Description:
*/

#include <iostream>
using namespace std;
#define LENGTH 6

//用以进行哈夫曼编码
int code[20];

//用以保存哈夫曼编码
string huffman[LENGTH];
int arr[LENGTH] = {12,24,35,67,46,55};
char alph[LENGTH] = {'A','B','C','D','E','F'};

typedef struct Tree {
    //节点的权值
    int data;
    Tree* leftSon;
    Tree* rightSon;
    Tree(int data,Tree* leftSon,Tree* rightSon){
        this->data = data;
        this->leftSon = leftSon;
        this->rightSon = rightSon;
    }
} Tree, *TreeList;

int cmp(TreeList &t1, TreeList &t2){
	return t1->data <= t2->data;
}

//建哈夫曼树,返回根节点
TreeList createTree(int arr[]) {
    //建立指vector用来保存节点信息
    vector<TreeList> v;
    for (int i = 0; i < LENGTH; i++) {
    	TreeList leat = new Tree(arr[i], nullptr, nullptr);
    	v.push_back(leat);
    }
    //哈夫曼树的根节点
    TreeList root = nullptr;
    //容器容量大于1说明还未建立完
    while(v.size() > 1){
    	//按照节点值从小到达排序
    	sort(v.begin(),v.end(),cmp);
        //最小值节点为v0次小值节点为v1
        root = new Tree(v[0]->data + v[1]->data,v[0],v[1]);
		//根节点保存到v1
        v[1] = root;
        v.erase(v.begin());
	}
    return root;
}

//根据权值获取下标
int getIndex(int weight){
    for(int i = 0 ;i<LENGTH;i++){
        if(weight == arr[i]){
            return i;
        }
    }
}

//递归进行哈夫曼树编码,len是当前树的层数
void huffmanCoding(TreeList& root, int len) {
    if (root == nullptr) {
        return;
    }
    //若到叶子节点
    if (root->leftSon == nullptr && root->rightSon == nullptr) {
        //获取该节点权值对应的字符下标
        int index = getIndex(root->data);
        //保存该字符的哈夫曼编码
        for (int i = 0; i < len; i++) {
            huffman[index].push_back(code[i] + '0');
        }
        return;
    }
    //否则继续进行哈夫曼编码的操作
    //左侧分支都记为零
    code[len] = 0;
    huffmanCoding(root->leftSon, len + 1);
    //右侧分支都记为一
    code[len] = 1;
    huffmanCoding(root->rightSon, len + 1);

}

int main() {
    TreeList root = createTree(arr);
    huffmanCoding(root, 0);
    for (int i = 0; i < LENGTH; i++) {
        cout << alph[i] << "的哈夫曼编码是 : " << huffman[i] << endl;
    }
    return 0;
}
```

## 3.5 结果

![](http://cdn.hurra.ltd/img/20200715100403.png)

---

![](http://cdn.hurra.ltd/img/赞赏码.png)
