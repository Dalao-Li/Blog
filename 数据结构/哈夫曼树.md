- [一、 概念](#一-概念)
- [二、 过程](#二-过程)
  - [初始化值](#初始化值)
  - [2.1 建立](#21-建立)
  - [2.2 编码](#22-编码)
- [三、 代码实现](#三-代码实现)
  - [3.1 数据定义](#31-数据定义)
  - [3.2 构建](#32-构建)
  - [3.3 编码](#33-编码)
  - [3.4 全部代码](#34-全部代码)
  - [3.5 运行结果](#35-运行结果)
# 一、 概念

>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为哈夫曼树;哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。


# 二、 过程

## 初始化值
节点 | 权值 |   
-|-|-
A | 12 
B | 24 
C | 35 
D| 67
E | 46
F| 55

## 2.1 建立

每次从所有节点中选出`最小权值节点`与`次小权值节点`,合并;  

重复操作至所有节点合并为一棵树

![](http://cdn.hurra.ltd/img/20200624222845.png)

## 2.2 编码

对建立好的哈夫曼树,所有节点左儿子编为0,右儿子编为1,实现对各节点的编码
![](http://cdn.hurra.ltd/img/20200624223359.png)

# 三、 代码实现

## 3.1 数据定义
```c++
#define LENGTH 6

// 用以进行哈夫曼编码
int code[20];

// 用以保存每个节点的哈夫曼编码
string huffman[LENGTH];

// 权值
int arr[LENGTH] = {12,24,35,67,46,55}; 

// 节点
char alph[LENGTH] = {'A','B','C','D','E','F'}; 

typedef struct Tree {
    //节点的权值
    int data;
    Tree* leftSon;
    Tree* rightSon;
    Tree(int data,Tree* leftSon,Tree* rightSon){
        this->data = data;
        this->leftSon = leftSon;
        this->rightSon = rightSon;
    }
} Tree, *TreeList;

```

## 3.2 构建
```c++
//建哈夫曼树,返回根节点
TreeList createTree(int arr[]) {
    //建立指针数组用来保存节点信息
    TreeList leaves[LENGTH];
    for (int i = 0; i < LENGTH; i++) {
        TreeList leaf = new Tree(arr[i], nullptr, nullptr);
        leaves[i] = leaf;
    }
    //建立一个节点作为哈夫曼树的根节点
    TreeList root = nullptr;
    //建立哈夫曼树
    for (int i = 1; i < LENGTH; i++) {
        // min1表示最小权值的树根结点的下标,min2为次小权值节点的下标
        int min1 = -1, min2 = 0;
        //初始化min1与min2
        for (int j = 0; j < LENGTH; j++) {
            if (leaves[j] != nullptr && min1 == -1) {
                min1 = j;
                continue;
            }
            if (leaves[j] != nullptr) {
                min2 = j;
                break;
            }
        }
        //找出最小值和次小值节点的下标
        for (int j = min2; j < LENGTH; j++) {
            if (leaves[j] != nullptr) {
                if (leaves[j]->data < leaves[min1]->data) {
                    min2 = min1;
                    min1 = j;
                } else if (leaves[j]->data < leaves[min2]->data) {
                    min2 = j;
                }
            }
        }
        //用最小权值树和次小权值树建立一棵新树,root指向树根结点
        root = new Tree(leaves[min1]->data + leaves[min2]->data,leaves[min1],leaves[min2]);
        //将指向新树的指针赋给leaves指针数组中min1位置
        leaves[min1] = root;
        // min2位置为空
        leaves[min2] = nullptr;
    }
    return root;
}
```

## 3.3 编码
```c++
//根据权值获取下标 
int getIndex(int weight){
	for(int i = 0 ;i<LENGTH;i++){
		if(weight == arr[i]){
			return i;
		}
	}
} 

//递归进行哈夫曼树编码,len是当前树的层数
void huffmanCoding(TreeList& root, int len) {
    if (root == nullptr) {
        return;
    }
    //若到叶子节点
    if (root->leftSon == nullptr && root->rightSon == nullptr) {
        //获取该节点权值对应的字符下标
        int index = getIndex(root->data);
        //保存该字符的哈夫曼编码
        for (int i = 0; i < len; i++) {
            huffman[index].push_back(code[i] + '0');
        }
        return;
    }
    //否则继续进行哈夫曼编码的操作
    //左侧分支都记为零
    code[len] = 0;
    huffmanCoding(root->leftSon, len + 1);
    //右侧分支都记为一
    code[len] = 1;
    huffmanCoding(root->rightSon, len + 1);

}
```

## 3.4 全部代码
```c++
/*
        Name: Huffman tree coding
        Copyright:
        Author: YuanHao Li
        Date: 20/5/24 15:22
        Description:
*/

#include <iostream>
using namespace std;
#define LENGTH 6

//用以进行哈夫曼编码
int code[20];

//用以保存哈夫曼编码
string huffman[LENGTH];
int arr[LENGTH] = {12,24,35,67,46,55};
char alph[LENGTH] = {'A','B','C','D','E','F'};

typedef struct Tree {
    //节点的权值
    int data;
    Tree* leftSon;
    Tree* rightSon;
    Tree(int data,Tree* leftSon,Tree* rightSon){
        this->data = data;
        this->leftSon = leftSon;
        this->rightSon = rightSon;
    }
} Tree, *TreeList;

//建哈夫曼树,返回根节点
TreeList createTree(int arr[]) {
    //建立指针数组用来保存节点信息
    TreeList leaves[LENGTH];
    for (int i = 0; i < LENGTH; i++) {
        TreeList leaf = new Tree(arr[i], nullptr, nullptr);
        leaves[i] = leaf;
    }
    //建立一个节点作为哈夫曼树的根节点
    TreeList root = nullptr;
    //建立哈夫曼树
    for (int i = 1; i < LENGTH; i++) {
        // min1表示最小权值的树根结点的下标,min2为次小权值节点的下标
        int min1 = -1, min2 = 0;
        //初始化min1与min2
        for (int j = 0; j < LENGTH; j++) {
            if (leaves[j] != nullptr && min1 == -1) {
                min1 = j;
                continue;
            }
            if (leaves[j] != nullptr) {
                min2 = j;
                break;
            }
        }
        //找出最小值和次小值节点的下标
        for (int j = min2; j < LENGTH; j++) {
            if (leaves[j] != nullptr) {
                if (leaves[j]->data < leaves[min1]->data) {
                    min2 = min1;
                    min1 = j;
                } else if (leaves[j]->data < leaves[min2]->data) {
                    min2 = j;
                }
            }
        }

        //用最小权值树和次小权值树建立一棵新树,root指向树根结点
        root = new Tree(leaves[min1]->data + leaves[min2]->data,leaves[min1],leaves[min2]);
        //将指向新树的指针赋给leaves指针数组中min1位置
        leaves[min1] = root;
        // min2位置为空
        leaves[min2] = nullptr;
    }
    return root;
}

//根据权值获取下标
int getIndex(int weight){
    for(int i = 0 ;i<LENGTH;i++){
        if(weight == arr[i]){
            return i;
        }
    }
}

//递归进行哈夫曼树编码,len是当前树的层数
void huffmanCoding(TreeList& root, int len) {
    if (root == nullptr) {
        return;
    }
    //若到叶子节点
    if (root->leftSon == nullptr && root->rightSon == nullptr) {
        //获取该节点权值对应的字符下标
        int index = getIndex(root->data);
        //保存该字符的哈夫曼编码
        for (int i = 0; i < len; i++) {
            huffman[index].push_back(code[i] + '0');
        }
        return;
    }
    //否则继续进行哈夫曼编码的操作
    //左侧分支都记为零
    code[len] = 0;
    huffmanCoding(root->leftSon, len + 1);
    //右侧分支都记为一
    code[len] = 1;
    huffmanCoding(root->rightSon, len + 1);

}

int main() {
    TreeList root = createTree(arr);
    huffmanCoding(root, 0);
    for (int i = 0; i < LENGTH; i++) {
        cout << alph[i] << "的哈夫曼编码是 : " << huffman[i] << endl;
    }
    return 0;
}
```

## 3.5 运行结果
![](http://cdn.hurra.ltd/img/20200715100403.png)


---

![](http://cdn.hurra.ltd/img/赞赏码.png)


