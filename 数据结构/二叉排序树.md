# 一、概念

二叉排序树:Binary Sort Tree(BST),也称二叉查找树

二叉排序树为非空树时有如下特点:
> - 若左子树非空,则左子树上所有结点值均`小于`其根结点值  
> - 若右子树非空,则右子树上所有结点值均`大于`其根结点值  
> - 其左、右子树本身也是一棵二叉排序树
> - 没有键值相等的结点

![](http://cdn.hurra.ltd/img/20200713145026.png)

对该树进行中序遍历(LDR) : `9 11 23 45 58 76`

结论 :中序遍历二叉排序树时会得到一个递增的有序序列

# 二、性质

## 节点定义
```c++
template<class T>
struct BSTNode{
    T value;
    BSTNode<T> *leftSon;
    BSTNode<T> *rightSon;
    BSTNode(T value,BSTNode<T> *leftSon,BSTNode<T> *rightSon){
        this->value = value;
        this->leftSon = leftSon;
        this->rightSon = rightSon;
    }
};
```

## 2.1 查找

> - 二叉树非空时,查找根结点,若值相等则查找成功,
> - 若不相等,当值小于根结点值时,查找左子树;大于根结点值时,查找右子树
> - 查找到叶节点仍未找到,查找失败

![](http://cdn.hurra.ltd/img/20200713145026.png)

查找23 : 因为`23<45`则查找左子树;因为`23>11`则查找右子树;`23=23`则查找成功  
查找47 : 因为`47<45`则查找右子树;因为`47<58`则查找左子树;左子树为空,则查找失败


```c++
//查找
template<class T>
BSTNode<T> *searchBST(BSTNode<T> *root,T value){
    //当前节点为空,说明未找到
    if(root == nullptr){
        return nullptr;
    }
    if(root->value == value){
        return root;
    }
    //查找左子树
    if(root->value > value){
        return searchBST(root->lchind,value);
    }
    //查找右子树
    if(root->value < value){
        return searchBST(root->rchind,value);
    }
    
}
```

## 2.2 插入
> - 若二叉排序树为空,直接插入结点;
> - 若二叉排序树非空,当值`小于`根结点时,插入`左子树`;当值`大于`根结点时,插入`右子树`;
> - 若等于根结点时不进行插入  
> - `新插入的结点总是叶子结点`


![](http://cdn.hurra.ltd/img/20200713151801.png)

插入15 : 因为`15<45`则选择左子树;因为`15>11`则选择右子树;`15<23`则选择左子树;左子树为空,则插入  

```c++
template<class T>
BSTNode<T> *insertBST(BSTNode<T> *root,T value){
    //当前节点为空,说明是叶子节点,可以插入
    if(root == nullptr){
        root = new BSTNode<T>(value,nullptr,nullptr);
        return root;
    }
    //值小于根结点时,插入根节点的左子树
    if(root->value > value){
        root->leftSon = insertBST(root->leftSon,value);
    }
    //值大于根结点时,插入根节点的右子树
    if(root->value < value){
        root->rightSon = insertBST(root->rightSon,value);
    }
    return root;
}

```
## 2.3 构建

使初始根节点为空,进行插入操作即可
```c++
template<class T>
void createBST(BSTNode<T> *&root,vector<T> v){
    for(int i = 0;size = v.size();i < size;i++){
        root = insertBST(root,v[i]);
    }
}
```

## 2.4 删除

> - 若被删除的结点是`叶子结点`,可以`直接删除`
> - 若被删除的结点X`只有一个子树`，则让X的`子树`成为X`父结点的子树`,代替X结点
> - 若被删除的结点X`有两个子树`，则让X的`右子树中最小节点`代替X,并删除最小节点

![](http://cdn.hurra.ltd/img/20200713145026.png)

---
1. 情况1 : 删除9  
由于9是叶子节点,则直接删除

![](http://cdn.hurra.ltd/img/20200713160057.png)
---

2. 情况2 : 删除58  
由于58节点只有一个子树,则让58的子树76,成为58的父节点45的子树

![](http://cdn.hurra.ltd/img/20200713160434.png)

---
3. 情况3 : 删除11  
11的右子树中最小节点为23,则让23代替11

![](http://cdn.hurra.ltd/img/20200713161254.png)

![](http://cdn.hurra.ltd/img/20200713161320.png)


```c++
template<class T>
void deleteBST(BSTNode<T> *&root,T value){
    if(root == nullptr){
        return;
    }
    //p为待删除节点,fp为其父节点
    BSTNode<T> *fp,*p = root;
    while(p->value != value){
        if(p->value > value){
            fp = p;
            p = p->leftSon;
        }
        if(p->value < value){
            fp = p;
            p = p->rightSon;
        }
    }
    //情况1:p为叶子节点直接删
    if(p->leftSon == nullptr && p->rightSon == nullptr){
        if(fp->leftSon != nullptr){
            fp->leftSon = nullptr;
        }
        if(fp->rightSon != nullptr){
            fp->rightSon = nullptr;
        }
        delete(p);
        return;
    }
    //情况2:p左子树为空则重接右子树
    if(p->leftSon == nullptr){
        p->value = p->rightSon->value;
        p->rightSon = nullptr;
        delete(p);
        return;
    }
    //情况3:p右子树为空则重接左子树
    if(p->rightSon == nullptr){
        p->value = p->leftSon->value;
        p->leftSon = nullptr;
        delete(p->leftSon);
        return;
    }
    //情况4:p左右子树均不为空时,需要找p右子树中最小节点(最左节点)q
    BSTNode<T> *q = p->rightSon;
    //s为q的父节点
    BSTNode<T> *s = q;
    //循环查找左节点，就会找到最小值
    while(q->leftSon != nullptr){
        s = q;
        q = q->leftSon;
    }
    s->leftSon = nullptr;
    //用最小值节点代替欲删除节点
    p->value = q->value;
    delete(q);
}
```

## 2.5 遍历
对二叉排序树采取中序遍历的方式
```c++
//遍历
template<class T>
void outputBST(BSTNode<T> *root){
    if(root->leftSon != nullptr){
        outputBST(root->leftSon);
    }
    cout<<root->value<<"== ";
    if(root->rightSon != nullptr){
        outputBST(root->rightSon);
    }
}
```

# 三、完整测试代码
```c
#include<iostream>
#include<vector>

using namespace std;

//节点定义
template<class T>
struct BSTNode {
    T value;
    BSTNode<T> *leftSon;
    BSTNode<T> *rightSon;
    BSTNode(T value,BSTNode<T> *leftSon,BSTNode<T> *rightSon){
        this->value = value;
        this->leftSon = leftSon;
        this->rightSon = rightSon;
    }
};

//查找
template<class T>
BSTNode<T> *searchBST(BSTNode<T> *&root,T value){
    if(root == nullptr){
        return nullptr;
    }
    if(root->value == value){
        return root;
    }
    //查找左子树
    if(root->value > value){
        return searchBST(root->leftSon,value);
    }
    //查找右子树
    if(root->value < value){
        return searchBST(root->rightSon,value);
    }
}


//插入
template<class T>
BSTNode<T> *insertBST(BSTNode<T> *&root,T value){
    //当前节点为空,说明是叶子节点,可以插入
    if(root == nullptr){
        root = new BSTNode<T>(value,nullptr,nullptr);
        return root;
    }
    //值小于根结点时,插入根节点的左子树
    if(root->value > value){
        root->leftSon = insertBST(root->leftSon,value);
    }
    //值大于根结点时,插入根节点的右子树
    if(root->value < value){
        root->rightSon = insertBST(root->rightSon,value);
    }
    return root;
}

//构建
template<class T>
void createBST(BSTNode<T> *&root,vector<T> v){
    for(int i = 0,size = v.size();i < size;i++){
        root = insertBST(root,v[i]);
    }
}

//遍历
template<class T>
void outputBST(BSTNode<T> *&root){
    if(root == nullptr){
        return;
    }
    outputBST(root->leftSon);
    cout<<root->value<<" ";
    outputBST(root->rightSon);
}

//删除
template<class T>
void deleteBST(BSTNode<T> *&root,T value){
    if(root == nullptr){
        return;
    }
    //p为待删除节点,fp为其父节点
    BSTNode<T> *fp,*p = root;
    while(p->value != value){
        if(p->value > value){
            fp = p;
            p = p->leftSon;
        }
        if(p->value < value){
            fp = p;
            p = p->rightSon;
        }
    }
    //情况1:p为叶子节点直接删
    if(p->leftSon == nullptr && p->rightSon == nullptr){
        if(fp->leftSon != nullptr){
            fp->leftSon = nullptr;
        }
        if(fp->rightSon != nullptr){
            fp->rightSon = nullptr;
        }
        delete(p);
        return;
    }
    //情况2:p左子树为空则重接右子树
    if(p->leftSon == nullptr){
        p->value = p->rightSon->value;
        p->rightSon = nullptr;
        delete(p);
        return;
    }
    //情况3:p右子树为空则重接左子树
    if(p->rightSon == nullptr){
        p->value = p->leftSon->value;
        p->leftSon = nullptr;
        delete(p->leftSon);
        return;
    }
    //情况4:p左右子树均不为空时,需要找p右子树中最小节点(最左节点)q
    BSTNode<T> *q = p->rightSon;
    //s为q的父节点
    BSTNode<T> *s = q;
    //循环查找左节点，就会找到最小值
    while(q->leftSon != nullptr){
        s = q;
        q = q->leftSon;
    }
    s->leftSon = nullptr;
    //用最小值节点代替欲删除节点
    p->value = q->value;
    delete(q);
}

int main(int argv,char *argc[]) {
    vector<int> v = {11,45,9,23,76,58};

    BSTNode<int> *root = nullptr;
    createBST(root,v);
    cout<<"二叉排序树的中序遍历结果: ";
    outputBST(root);
    cout<<endl;

    //插入值
    int newNode = 35;
    cout<<"插入新值:"<<newNode<<endl;
    root = insertBST(root,newNode);
    cout<<"插入新值后二叉排序树的中序遍历结果: ";
    outputBST(root);
    cout<<endl;

    //删除值
    int delNode = 35;
    cout<<"删除值:"<<delNode<<endl;
    deleteBST(root,delNode);
    cout<<"删除值后二叉排序树的中序遍历结果: ";
    outputBST(root);
    cout<<endl;
}
```
运行结果:

![](http://cdn.hurra.ltd/img/20200714234856.png)

---

![](http://cdn.hurra.ltd/img/赞赏码.png)
