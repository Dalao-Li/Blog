# 一、并查集

## 1.概念

![](http://cdn.hurra.ltd/img/20200515163207.png)
- 和尚和张大彪咋知道是自己人?因为他们的团长都是李云龙
- 李云龙和孔二愣子咋知道是自己人?因为他们的上司都是旅长  
- 李云龙和楚云飞最后为啥兵戎相见,因为他们的上司不一样,所以不是自己人

并查集用于划分子集  
例如独立团中两个士兵在突围中相遇,为了识别身份,就开始找上司,假设团长就是最大的,那么士兵就得按照班长->排长->营长->团长的顺序一直报下去,若相同则肯定是自己人

话说反扫荡开始了,八路军以团为单位分散突围,现在有一队士兵相遇,需要尽快确认他们各自所属的团,也就是构建以团长为根节点的树

--- 

## 2.代码实现


### 2.1.数组p[]
```c++
//X的上司是Y
p[X] = Y


```
例如: p[张大彪] = 李云龙  
同时,团长作为根节点,其上司就为自己

---

### 2.2 人员初始化
```c++
void init(){
    for(int i = 0 ; i< n ;i++){
        //初始时每个人的上司设为自己
        p[i] = i;
    }
}
```
---
### 2.3 找团长

```c++
int find(int i){
    int b = i;s
    //找团长
    while(i!=p[i]){
        i = p[i];
    }
    //路径压缩
    while(b!=i){
        p[b] = i;
        b = p[b];
    }
}
```
>找团长部分:当i的上司不是自己时就继续找自己的上司  
>路径压缩部分:压缩了i寻找上司的路径,例如:
```c++
//i的上司是张大彪 
p[i] = 张大彪
//张大彪的上司是李云龙 
p[张大彪] = 李云龙
//那么为了节约查找路径就可直接将i的上司设为李云龙
p[i] = 李云龙
```
---
### 2.4 合并
```c++
//将a的上司设置为b
void merge(int a,int b){
    int x = find(a);
    int y = find(b);
    //上司不同
    if(x != y){
        p[x] = y;
    }
}
```
>二营长找好了自己手下的一队人马,三营长也找好了自己的一队人马,这时二营长和三营长遇见了,为了方便管理,就暂时以三营长为上司,合并了两个队

---

### 2.5 统计集合数量
```c++
int count(){
    int sum = 0;
    for(int i = 0 ; i< n  ;i++{
        if(i == p[i]){
            sum++;
        }
    }
    return sum;
}
```
也就是看一下队伍中团长的个数,统计以下有多少个子集
