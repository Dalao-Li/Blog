<!--
 * @Description: 
 * @Version: 1.0
 * @Author: Li Yuanhao
 * @Email: dalao_li@163.com
 * @Date: 2021-03-15 14:09:06
 * @LastEditors: Li Yuanhao
 * @LastEditTime: 2021-03-16 19:12:05
-->

分散到多个 Dockerfile

另一种方式,就是我们事先在一个 Dockerfile 将项目及其依赖库编译测试打包好后,再将其拷贝到运行环境中,这种方式需要我们编写两个 Dockerfile 和一些编译脚本才能将其两个阶段自动整合起来,这种方式虽然可以很好地规避第一种方式存在的风险,但明显部署过程较复杂

## 使用多阶段构建

为解决以上问题,Docker v17.05 开始支持多阶段构建 (multistage builds)。使用多阶段构建我们就可以很容易解决前面提到的问题,并且只需要编写一个 Dockerfile:


app.go文件

```go
package main

import "fmt"

func main(){
    fmt.Printf("Hello World!");
}
```

Dockerfile 文件

```docker
FROM golang:1.9-alpine as builder

RUN apk --no-cache add git

# 工作空间
WORKDIR /go/src/github.com/go/helloworld/

RUN go get -d -v github.com/go-sql-driver/mysql

COPY app.go .

RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

# 第二阶段
FROM alpine:latest as prod

RUN apk --no-cache add ca-certificates

WORKDIR /root/

# 从第一阶段中拷贝文件
COPY --from=builder /go/src/github.com/go/helloworld/app .

CMD ["./app"]
```



## 只构建某一阶段的镜像

使用 as 来为某一阶段命名，例如

```sh
FROM golang:1.9-alpine as builder
```

例如当只想构建 builder 阶段的镜像时，增加 --target=builder 参数即可

```sh
docker build --target builder -t [镜像名]:[tag] .
```

## 构建时从其他镜像复制文件

上面例子中我们使用 COPY --from=0 /go/src/github.com/go/helloworld/app . 从上一阶段的镜像中复制文件，当然也可以复制任意镜像中的文件.

```sh
# 例如复制nginx:latest镜像中的nginx.conf文件
COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf
```