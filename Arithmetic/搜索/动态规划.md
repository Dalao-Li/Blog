# 动态规划思路

- 原问题 子问题
- 中间状态
- 边界值
- `状态转移方程`

## 数组最优解



从 n 个数的数组,取出若干个数两两不相邻的数,求取出的数最大和

- 原问题 : n 个数取出和最大的最优解
- 子问题 : 前 1 个数的最优解,前 2 个数的最优解......前 n 个数的最优解......
- 中间状态 : $dp[i]$代表前 i 个数的最优解,最终求 $dp[n]$
- 边界值 : $dp[1] = a[1] ,dp[2] = max(dp[1] ,a[2])$
- 状态转移方程 : 前 $i$ 个数的最优解,重点是考虑加不加第 i 个数 $a[i]$;若不加可从 $dp[i-1]$转移过来,若加只能从 $dp[i-2]$转移过来(`选择的数不能相邻`)
  然后再取两种情况的最大值.因此: $dp[i] = max( dp[i-1], dp[i-2]+a[i] ) 且i>=2$

## 连续数组最大和



在一个数组中 $a[n]$有正数有负数,求取出的连续子数组中最大和

- 原问题 : 前 $n$个数中连续子数组最大和
- 子问题 : 前 1 个数的最大和,前 2 个数的最大和......前 n 个数的最大和......
- 中间状态 : $dp[i]$代表前 $i$ 个数的最大和,最终需求 $dp[n]$
- 边界值 : $dp[1] = a[1] dp[2] = max(dp[2] ,dp[2]+a[1])$
- 状态转移方程 : 对于状态 i 来说,若前一状态 $dp[i-1]$为负数,则不需要前面的数,新状态为 $a[i]$;若 $dp[i-1]$是正数,那就可以加上 $a[i]$.关键就在于前面的状态还要不要加上
  $dp[i]=max( a[i], dp[i-1]+a[i]) 且i>=1$

## 求出数组最长上升子序列的长度

- 原问题 : 前 n 个数中最长上升子序列
- 子问题 : 前 1 个数的最长上升子序列......前 n 个数的最长上升子序列......
- 中间状态 : $dp[i]$代表前 i 个数的最长上升子序列,最终需求 $dp[n]$
- 边界值 : $dp[1] = 1$
- 状态转移方程 : $i = 2$ 时,$dp[2] = max(dp[1],dp[1]+1)$,即判断 $a[1]$大于或小于 a[2]的情况;对于状态 i 来说 $dp[i] = max(dp[i],dp[j]+1), {j< i 并且 a[j] < a[i]}$

```c
for(int i = 2 ; i <= n ; i++){
    dp[i] = 1;
    for(int j = 1 ; j < i ; j++){
        if(a[j] < a[i]){
            dp[i] = max(dp[i],dp[j]+1);
        }
    }
}
```

## 例 4

有面值为 1,3,5 的硬币若干枚,如何用最少的硬币凑够 n 元

- 原问题 : 凑够 n 元所需最少硬币
- 中间状态 : $dp[i]$代表凑够 i 元所需最少硬币,最终需求 dp[n]
- 边界值 : $dp[1] = 1$
- 状态转移方程 : $dp[i] = min(dp[i-1],dp[i-3],dp[i-5]) + 1$

```c
//v[i]代表硬币的面额
v[1] = 1,v[2] = 3,v[3] = 5;
for(int i = 1 ; i <= n ; i++){
    for(int j = 3 ; j >= 1 j--){
        if(i > v[j]){
            dp[i] = min(dp[i],dp[i-v[j]]+1)
        }
    }
}
```

## 例 5

无向图 G 有个 n 结点及一些边,每条边带有正的权重值.找到结点 1 到结点 n 的最短路径

- 原问题 : 找到节点 1 到节点 n 的最短路径

- 中间状态 : $dp[i]$到节点 i 的最短路径,最终需求 dp[n]
- 边界值 : $dp[1] = 0$
- 状态转移方程 : $dp[i] = min(dp[i] , dp[j]+dis[i][j]), {dis[i][j] 代表 j 到 i 的距离}$

```c
const MAX = 0x7fffffff;

dp[1] = 0;
for(int i = 1 ; i <= n ; i++){
    for(int j = 1 ; j < i ; j++){
        //若i能到j
        if(dis[i][j] < MAX){
            dp[i] = min(dp[i] , dp[j]+dis[i][j])
        }
    }
}
```

## 例 6

平面上有 n\*m 个格子,每个格子中放一定数量的苹果 a[i][j],从左上角开始,每一步只能向下或向右走,走到一个格子获得格子内苹果,走到右下角最多能收集到多少个苹果

- 中间状态 : $dp[i][j]$代表走到$[i,j]$时获得的苹果数
- 边界值 $dp[i][1] = dp[i-1][1]+a[i][1] ; dp[1][j] = dp[i][j-1] +a[1][j]$
- 状态转移方程 : $dp[i][j] = max(dp[i-1][j]+ dp[i][j-1])+a[i][j]$

```c
dp[1][1] = a[1][1];

for(int i = 1 ; i <=n ; i++){
    for(int j = 1 ; j <=n ; j++){
        if(i == 1){
            dp[i][j] = dp[i][j-1] + a[i][j]
        }
        else if(j == 1){
            dp[i][j] = dp[i-1][j] + a[i][j]
        }
        else{
            dp[i][j] = max(dp[i-1][j]+ dp[i][j-1])+a[i][j]
        }
    }
}
```

☝
![](http://cdn.hurra.ltd/img/收款码.png)
