# 概念

二叉排序树:Binary Sort Tree(BST),也称二叉查找树

二叉排序树为非空树时有如下特点:

> - 若左子树非空,则左子树上所有结点值均`小于`其根结点值
> - 若右子树非空,则右子树上所有结点值均`大于`其根结点值
> - 其左、右子树也是二叉排序树
> - 没有键值相等的结点

![](https://cdn.hurra.ltd/img/20200713145026.png)

对该树进行中序遍历(LDR) : 9 11 23 45 58 76

结论 :中序遍历二叉排序树时会得到一个递增的有序序列

# 性质

## 节点定义

```c++
template<class T>

struct BSTNode{
    T value;
    BSTNode<T> *leftSon;
    BSTNode<T> *rightSon;

    BSTNode(T value, BSTNode<T> *leftSon, BSTNode<T> *rightSon){
        this->value = value;
        this->leftSon = leftSon;
        this->rightSon = rightSon;
    }
};
```

## 查找

> - 二叉树非空时,查找根结点,若值相等则查找成功,
> - 若不相等,当值小于根结点值时,查找左子树;大于根结点值时,查找右子树
> - 查找到叶节点仍未找到,查找失败

![](https://cdn.hurra.ltd/img/20200713145026.png)

查找 23 : 因为`23<45`则查找左子树;因为`23>11`则查找右子树;`23=23`则查找成功  
查找 47 : 因为`47<45`则查找右子树;因为`47<58`则查找左子树;左子树为空,则查找失败

- 递归写法

```c++
template<class T>

BSTNode<T> *searchBST(BSTNode<T> *root,T value){
    //当前节点为空,说明未找到
    if(root == nullptr){
        return nullptr;
    }
    if(root->value == value){
        return root;
    }
    //查找左子树
    if(root->value > value){
        return searchBST(root->lchind,value);
    }
    //查找右子树
    if(root->value < value){
        return searchBST(root->rchind,value);
    }
}
```

- 非递归写法

```c++
template<class T>

BSTNode<T> *searchBST(BSTNode<T> *root,T value){
    while(root){
        if(root->value == value){
            return root;
        }
        //查找左子树
        else if(root->value > value){
            root = root->lchind;
        }
        //查找右子树
        else if(root->value < value){
            root = root->rchind;
        }
    }
    //当前节点为空,说明未找到
    return nullptr;
}
```

## 插入

> - 若二叉排序树为空,直接插入结点;
> - 若二叉排序树非空,当值`小于`根结点时,插入`左子树`;当值`大于`根结点时,插入`右子树`;
> - 若等于根结点时不进行插入
> - 新插入的结点总是`叶子结点`

![](https://cdn.hurra.ltd/img/20200713151801.png)

插入 15 : 因为`15<45`则选择左子树;因为`15>11`则选择右子树;`15<23`则选择左子树;左子树为空,则插入

- 递归写法

```c++
template<class T>
BSTNode<T> *insertBST(BSTNode<T> *root,T value){
    //当前节点为空,说明是叶子节点,可以插入
    if(root == nullptr){
        root = new BSTNode<T>(value,nullptr,nullptr);
        return root;
    }
    //值小于根结点时,插入根节点的左子树
    if(root->value > value){
        root->leftSon = insertBST(root->leftSon,value);
    }
    //值大于根结点时,插入根节点的右子树
    if(root->value < value){
        root->rightSon = insertBST(root->rightSon,value);
    }
    return root;
}

```

## 构建

使初始根节点为空,进行插入操作即可

```c++
template<class T>
void createBST(BSTNode<T> *&root,vector<T> v){
    for(int i = 0;size = v.size();i < size;i++){
        root = insertBST(root,v[i]);
    }
}
```

## 删除

> - 若被删除的结点是`叶子结点`,可以`直接删除`
> - 若被删除的结点 X`只有一个子树`,则让 X 的`子树`成为 X`父结点的子树`,代替 X 结点
> - 若被删除的结点 X`有两个子树`,则让 X 的`右子树中最小节点`代替 X,并删除最小节点

![](https://cdn.hurra.ltd/img/20200713145026.png)

---

1. 情况 1 : 删除 9  
   由于 9 是叶子节点,则直接删除

## ![](https://cdn.hurra.ltd/img/20200713160057.png)

2. 情况 2 : 删除 58  
   由于 58 节点只有一个子树,则让 58 的子树 76,成为 58 的父节点 45 的子树

![](https://cdn.hurra.ltd/img/20200713160434.png)

---

3. 情况 3 : 删除 11  
   11 的右子树中最小节点为 23,则让 23 代替 11

![](https://cdn.hurra.ltd/img/20200713161254.png)

![](https://cdn.hurra.ltd/img/20200713161320.png)

```c++
template<class T>
void deleteBST(BSTNode<T> *&root,T value){
    if(root == nullptr){
        return;
    }
    //p为待删除节点,fp为其父节点
    BSTNode<T> *fp,*p = root;
    while(p->value != value){
        if(p->value > value){
            fp = p;
            p = p->leftSon;
        }
        if(p->value < value){
            fp = p;
            p = p->rightSon;
        }
    }
    //情况1:p为叶子节点直接删
    if(p->leftSon == nullptr && p->rightSon == nullptr){
        if(fp->leftSon != nullptr){
            fp->leftSon = nullptr;
        }
        if(fp->rightSon != nullptr){
            fp->rightSon = nullptr;
        }
        delete(p);
        return;
    }
    //情况2:p左子树为空则重接右子树
    else if(p->leftSon == nullptr){
        p->value = p->rightSon->value;
        p->rightSon = nullptr;
        delete(p);
        return;
    }
    //情况3:p右子树为空则重接左子树
    else if(p->rightSon == nullptr){
        p->value = p->leftSon->value;
        p->leftSon = nullptr;
        delete(p->leftSon);
        return;
    }
    //情况4:p左右子树均不为空时,需要找p右子树中最小节点(最左节点)q
    BSTNode<T> *q = p->rightSon;
    //s为q的父节点
    BSTNode<T> *s = q;
    //循环查找左节点,就会找到最小值
    while(q->leftSon != nullptr){
        s = q;
        q = q->leftSon;
    }
    s->leftSon = nullptr;
    //用最小值节点代替欲删除节点
    p->value = q->value;
    delete(q);
}
```

## 遍历

对二叉排序树采取中序遍历的方式

```c++
//遍历
template<class T>

void outputBST(BSTNode<T> *root){
    if(root->leftSon != nullptr){
        outputBST(root->leftSon);
    }

    cout<<root->value<<"== ";

    if(root->rightSon != nullptr){
        outputBST(root->rightSon);
    }
}
```

# 完整测试代码

```c
#include<iostream>
#include<vector>

using namespace std;

//节点定义
template<class T>
struct BSTNode {
    T value;
    BSTNode<T> *leftSon;
    BSTNode<T> *rightSon;
    BSTNode(T value,BSTNode<T> *leftSon,BSTNode<T> *rightSon){
        this->value = value;
        this->leftSon = leftSon;
        this->rightSon = rightSon;
    }
};

//查找
template<class T>
BSTNode<T> *searchBST(BSTNode<T> *&root,T value){
    if(root == nullptr){
        return nullptr;
    }
    if(root->value == value){
        return root;
    }
    if(root->value > value){
        return searchBST(root->leftSon,value);
    }
    if(root->value < value){
        return searchBST(root->rightSon,value);
    }
}


//插入
template<class T>
BSTNode<T> *insertBST(BSTNode<T> *&root,T value){
    //当前节点为空,说明是叶子节点,可以插入
    if(root == nullptr){
        root = new BSTNode<T>(value,nullptr,nullptr);
        return root;
    }
    //值小于根结点时,插入根节点的左子树
    if(root->value > value){
        root->leftSon = insertBST(root->leftSon,value);
    }
    //值大于根结点时,插入根节点的右子树
    if(root->value < value){
        root->rightSon = insertBST(root->rightSon,value);
    }
    return root;
}

//构建
template<class T>
void createBST(BSTNode<T> *&root,vector<T> v){
    for(int i = 0,size = v.size();i < size;i++){
        root = insertBST(root,v[i]);
    }
}

//遍历
template<class T>
void outputBST(BSTNode<T> *&root){
    if(root == nullptr){
        return;
    }
    outputBST(root->leftSon);
    cout<<root->value<<" ";
    outputBST(root->rightSon);
}

//删除
template<class T>
void deleteBST(BSTNode<T> *&root,T value){
    if(root == nullptr){
        return;
    }
    //p为待删除节点,fp为其父节点
    BSTNode<T> *fp,*p = root;
    while(p->value != value){
        if(p->value > value){
            fp = p;
            p = p->leftSon;
        }
        if(p->value < value){
            fp = p;
            p = p->rightSon;
        }
    }
    //情况1:p为叶子节点直接删
    if(p->leftSon == nullptr && p->rightSon == nullptr){
        if(fp->leftSon != nullptr){
            fp->leftSon = nullptr;
        }
        if(fp->rightSon != nullptr){
            fp->rightSon = nullptr;
        }
        delete(p);
        return;
    }
    //情况2:p左子树为空则重接右子树
    if(p->leftSon == nullptr){
        p->value = p->rightSon->value;
        p->rightSon = nullptr;
        delete(p);
        return;
    }
    //情况3:p右子树为空则重接左子树
    if(p->rightSon == nullptr){
        p->value = p->leftSon->value;
        p->leftSon = nullptr;
        delete(p->leftSon);
        return;
    }
    //情况4:p左右子树均不为空时,需要找p右子树中最小节点(最左节点)q
    BSTNode<T> *q = p->rightSon;
    //s为q的父节点
    BSTNode<T> *s = q;
    //循环查找左节点,就会找到最小值
    while(q->leftSon != nullptr){
        s = q;
        q = q->leftSon;
    }
    s->leftSon = nullptr;
    //用最小值节点代替欲删除节点
    p->value = q->value;
    delete(q);
}

int main(int argv,char *argc[]) {
    vector<int> v = {11,45,9,23,76,58};

    BSTNode<int> *root = nullptr;
    createBST(root,v);
    cout<<"二叉排序树的中序遍历结果: ";
    outputBST(root);
    cout<<endl;

    //插入值
    int newNode = 35;
    cout<<"插入新值:"<<newNode<<endl;
    root = insertBST(root,newNode);
    cout<<"插入新值后二叉排序树的中序遍历结果: ";
    outputBST(root);
    cout<<endl;

    //删除值
    int delNode = 35;
    cout<<"删除值:"<<delNode<<endl;
    deleteBST(root,delNode);
    cout<<"删除值后二叉排序树的中序遍历结果: ";
    outputBST(root);
    cout<<endl;
}
```

运行结果:

![](https://cdn.hurra.ltd/img/20200714234856.png)

---

![](https://cdn.hurra.ltd/img/收款码.png)
